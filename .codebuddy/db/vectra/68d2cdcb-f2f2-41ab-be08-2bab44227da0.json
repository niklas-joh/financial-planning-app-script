{"chunk":8,"numChunks":10,"fileHash":"qKty2YPjJfk9NdZZT+Kl8Aescdwa/V3Jg8MhLZ7cQWs=","filePath":"src/tests/ui-service.test.js","content":"/**\n(function() {\n  T.registerTest(\"UIService\", \"showPromptDialog should call ui.prompt and return text on OK\", function() {\n    resetMocks();\n    const inputText = \"User input text\";\n    promptResponse = { button: mockUi.Button.OK, text: inputText }; // Simulate OK + text\n    const title = \"Enter Value\";\n    const message = \"Please enter something:\";\n    const result = UIService.showPromptDialog(title, message);\n\n    T.assertNotNull(lastPrompt, \"ui.prompt should have been called.\");\n    T.assertEquals(title, lastPrompt.title, \"Prompt title should match.\");\n    T.assertEquals(message, lastPrompt.message, \"Prompt message should match.\");\n    T.assertEquals(mockUi.ButtonSet.OK_CANCEL, lastPrompt.buttons, \"Prompt should use OK_CANCEL button set.\");\n    T.assertEquals(inputText, result, \"Should return user text when OK is clicked.\");\n  });\n   T.registerTest(\"UIService\", \"showPromptDialog should use defaultValue (though mock doesn't fully support it)\", function() {\n    resetMocks();\n    // Note: The mock ui.prompt doesn't actually use the defaultValue, but we test the service calls it.\n    // A more complex mock could simulate pre-filling.\n    const defaultValue = \"Default Text\";\n     promptResponse = { button: mockUi.Button.OK, text: defaultValue }; // Simulate OK returning default\n    UIService.showPromptDialog(\"Title\", \"Message\", defaultValue);\n    // We mainly check the call was made correctly; the mock limitation prevents checking pre-fill.\n    T.assertNotNull(lastPrompt, \"ui.prompt should have been called.\");\n  });"}