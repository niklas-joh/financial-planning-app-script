{"chunk":5,"numChunks":23,"fileHash":"CQfg6CTbjaSJNNQcldTeFCWrygm/GYuNhHS4k156290=","filePath":"src/core/controllers.js","content":"/**\nconst ControllersModule = (function() {\n  /**\n   * Constructor for the ControllersModule.\n   * @param {object} configInstance - An instance of ConfigModule.\n   * @param {object} uiServiceInstance - An instance of UIServiceModule.\n   * @param {object} errorServiceInstance - An instance of ErrorServiceModule.\n   * @constructor\n   */\n  function ControllersModuleConstructor(configInstance, uiServiceInstance, errorServiceInstance) {\n    this.config = configInstance;\n    this.uiService = uiServiceInstance;\n    this.errorService = errorServiceInstance;\n\n    // Initialize wrapped methods after construction\n    this._initializeWrappedMethods();\n  }\n  ControllersModuleConstructor.prototype._wrapWithFeedback = function(fn, startMessage, successMessage, errorMessage) {\n    const self = this;\n    return function(...args) {\n      try {\n        if (startMessage) {\n          self.uiService.showLoadingSpinner(startMessage);\n        }\n        // Bind fn to self to ensure it has access to this.config, etc. if it's a method of ControllersModule\n        const result = fn.apply(self, args);\n        self.uiService.hideLoadingSpinner();\n        if (successMessage) {\n          self.uiService.showSuccessNotification(successMessage);\n        }\n        return result;\n      } catch (error) {\n        self.uiService.hideLoadingSpinner();\n        self.errorService.handle(\n          error,\n          errorMessage || 'An error occurred while performing the operation.'\n        );\n        throw error; // Re-throw so it can be caught by GAS if needed\n      }\n    };\n  };\n  // Core logic for controller actions (unwrapped)\n  // These will be wrapped and assigned to the instance in _initializeWrappedMethods"}